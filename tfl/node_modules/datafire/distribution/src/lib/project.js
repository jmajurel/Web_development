"use strict";

var nodepath = require('path');
var fs = require('fs');
var YAML = require('yamljs');
var CronJob = require('cron').CronJob;

var openapiUtil = require('../util/openapi');
var schedule = require('../util/schedule');
var ProjectServer = require('./project-server');
var Integration = require('./integration');
var Action = require('./action');
var Response = require('./response');
var Context = require('./context');
var Monitor = require('./monitor');

var Project = module.exports = function (opts) {
  this.id = opts.id || '';
  this.title = opts.title || '';
  this.version = opts.version || '1.0.0';
  this.timezone = opts.timezone || 'America/Los_Angeles';
  this.description = opts.description || '';
  this.paths = opts.paths || {};
  this.tasks = opts.tasks || {};
  this.tests = opts.tests || {};
  this.actions = opts.actions || {};
  this.integrations = opts.integrations || {};
  this.authorizers = opts.authorizers || {};
  this.accounts = opts.accounts || {};
  this.directory = opts.directory || process.cwd();
  this.options = opts.options || {};
  this.monitor = new Monitor();

  this.aggregateActions();
  this.initializeOpenAPI(opts.openapi || {});
  this.integration = Integration.fromOpenAPI(this.openapi, this.id);
};

Project.main = function () {
  if (Project.mainProject) return Project.mainProject;else return Project.mainProject = Project.fromDirectory(process.cwd());
};

Project.fromDirectory = function (dir) {
  var directory = dir || process.cwd();
  var opts = {};
  function assignFromFile(f) {
    var content = null;
    if (!fs.existsSync(f)) return;
    try {
      content = YAML.load(f);
    } catch (e) {
      console.log('While loading', f);
      throw e;
    }
    Object.assign(opts, content);
  }
  assignFromFile(nodepath.join(directory, 'DataFire.yml'));
  assignFromFile(nodepath.join(directory, 'DataFire-accounts.yml'));
  opts.directory = directory;
  return new Project(opts);
};

Project.prototype.aggregateActions = function () {
  var _this = this;

  for (var integID in this.integrations) {
    var loc = this.integrations[integID];
    this.integrations[integID] = require(nodepath.join(this.directory, loc));
  }

  for (var actionID in this.actions) {
    this.actions[actionID] = Action.fromName(this.actions[actionID], this.directory, this.integrations);
  }

  var resolveAction = function resolveAction(action) {
    if (typeof action === 'string') {
      if (_this.actions[action]) {
        action = _this.actions[action];
      } else {
        action = _this.actions[action] = Action.fromName(action, _this.directory, _this.integrations);
      }
    }
    if (!(action instanceof Action)) {
      action = new Action(action);
    }
    return action;
  };

  for (var authID in this.authorizers) {
    var authorizer = this.authorizers[authID];
    if (!authorizer.action) throw new Error('No action specified for authorizer ' + authID);
    authorizer.action = resolveAction(authorizer.action);
  }
  for (var taskID in this.tasks) {
    var task = this.tasks[taskID];
    if (!task.action) throw new Error('No action specified for task ' + taskID);
    task.action = resolveAction(task.action);
  }
  for (var path in this.paths) {
    for (var method in this.paths[path]) {
      var op = this.paths[path][method];
      if (!op.action) throw new Error('No action specified for ' + method.toUpperCase() + ' ' + path);
      op.action = resolveAction(op.action);

      for (var _authID in op.authorizers) {
        var _authorizer = op.authorizers[_authID];
        if (!_authorizer) continue;
        if (!_authorizer.action) throw new Error('No action specified for authorizer ' + _authID + ' in operation ' + method.toUpperCase() + ' ' + path);
        _authorizer.action = resolveAction(_authorizer.action);
      }
    }
  }
};

Project.prototype.initializeOpenAPI = function (openapi) {
  this.openapi = Object.assign({
    swagger: '2.0',
    schemes: ['http'],
    host: 'localhost',
    info: {},
    produces: ['application/json'],
    paths: {}
  }, openapi);
  Object.assign(this.openapi.info, {
    title: this.title,
    description: this.description,
    version: this.version
  }, openapi.info);

  for (var path in this.paths) {
    for (var method in this.paths[path]) {
      var pathOp = this.paths[path][method];
      this.openapi.paths[path] = this.openapi.paths[path] || {};
      var op = this.openapi.paths[path][method] = openapiUtil.getOperation(method, path, pathOp);
      if (pathOp.input !== undefined) op.parameters = [];
      if (pathOp.extendPath) {
        for (var i = 0; i < pathOp.extendPath; ++i) {
          path += '/{' + openapiUtil.EXTENDED_PATH_PARAM_NAME + i + '}';
          this.openapi.paths[path] = this.openapi.paths[path] || {};
          this.openapi.paths[path][method] = openapiUtil.getOperation(method, path, pathOp);
        }
      }
    }
  }
  return this.openapi;
};

Project.prototype.serve = function (opts) {
  opts = opts || {};
  if (typeof opts === 'number') opts = { port: opts };
  opts.port = opts.port || 3333;
  var numTasks = Object.keys(this.tasks).length;
  if (opts.tasks && numTasks) {
    this.startTasks();
    console.log("DataFire running " + numTasks + " task" + (numTasks > 1 ? 's' : ''));
  }
  if (opts.nohttp || !Object.keys(this.paths).length) {
    return Promise.resolve();
  } else {
    return this.startServer(opts.port);
  }
};

Project.prototype.startServer = function (port) {
  this.server = new ProjectServer(this);
  return this.server.start(port).then(function (_) {
    console.log('DataFire listening on port ' + port);
  });
};

Project.prototype.startTasks = function () {
  var _this2 = this;

  var _loop = function _loop(taskID) {
    var task = _this2.tasks[taskID];
    if (!task.schedule) return 'continue';
    var cron = schedule.parse(task.schedule);
    cron = schedule.cronToNodeCron(cron);
    var job = new CronJob(cron, function () {
      var event = _this2.monitor.startEvent('task', { id: taskID });
      return task.action.run(task.input, new Context({
        type: 'task',
        accounts: Object.assign({}, _this2.accounts, task.accounts)
      })).then(function (data) {
        event.success = true;
        event.output = data;
        _this2.monitor.endEvent(event);
      }, function (error) {
        event.success = false;
        event.error = error;
        _this2.monitor.endEvent(event);
      });
    }, null, true, _this2.timezone);
  };

  for (var taskID in this.tasks) {
    var _ret = _loop(taskID);

    if (_ret === 'continue') continue;
  }
};